/* 
 * Author: Ahmed Baig
 * Description: Takes a csv file and streams the values from the file at a set frequency across a network port
 * Date: September 2025
 * AI Disclosure: Code for GUI window and drawing a single line generated by ChatGPT, everything else done by me
*/

// GUI Includes
use eframe::egui;
use std::sync::mpsc;
use std::thread;

// Networking Includes
use std::str::from_utf8;
use std::net::UdpSocket;

// Constants
const BUFFER_SIZE: usize = 1000;

fn main() -> eframe::Result<()> {

    let rx: mpsc::Receiver<f32> = network_receive();

    let options = eframe::NativeOptions::default();
    eframe::run_native(
        "Receive Demo",
        options,
        Box::new(|_cc| Ok(Box::new(App{rx, vector_pos: 0, data_vec: vec![0.0; BUFFER_SIZE]}))),
    )
}

struct App {
    rx: mpsc::Receiver<f32>,
    vector_pos: i32,
    data_vec: Vec<f32>
}

impl eframe::App for App {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        
        egui::CentralPanel::default().show(ctx, |ui| {
            
            let painter = ui.painter();
            let window_size = ctx.input(|i: &egui::InputState| i.content_rect());

            // Receive data into buffer
            let j = self.rx.recv().unwrap();
            self.data_vec[self.vector_pos as usize] = j;

            let x_stretch_factor: f32 = window_size.max.x / 1000.0;

            // Plot data
            for i in 0..BUFFER_SIZE-1 {
                let a: egui::Pos2 = egui::Pos2{x: (i as f32 * x_stretch_factor), y: window_size.max.y - self.data_vec[i]};
                let b: egui::Pos2 = egui::Pos2{x: ((i + 1) as f32 * x_stretch_factor), y: window_size.max.y - self.data_vec[i + 1]};
                
                painter.line_segment(
            [a, b],
                    egui::Stroke::new(2.0, egui::Color32::WHITE),
                );

            }

            // Increment position
            self.vector_pos += 1;

            if self.vector_pos >= BUFFER_SIZE as i32 {
                self.vector_pos = 0;
            }

            ctx.request_repaint();
        });
    }
}

fn network_receive() -> mpsc::Receiver<f32> {
    let (tx, rx) = mpsc::sync_channel(0);
    thread::spawn(move || {
        loop {
            tx.send(network_get_data()).unwrap();
        }
    });

    rx
}

// This function contains everything related to receiving data over the network port
fn network_get_data() -> f32 {

    // Bind network port
    let socket: UdpSocket = UdpSocket::bind("127.0.0.1:12345").expect("Error: unable to bind socket");

    // Prepare buffer for receiving
    let mut buf: [u8; 10] = [0; 10];

    // Receive from network port
    let (number_of_bytes, _) = socket.recv_from(&mut buf).expect("Didn't receive data");
    let filled_buf: &mut [u8] = &mut buf[..number_of_bytes];

    // Convert byte array into string then to f32
    let string_message: String = from_utf8(filled_buf).expect("Unable to convert byte array to string").to_string();
    let num: f32 = string_message.parse::<f32>().expect("Unable to convert string into f32");

    // println!("Value Received: {}", num);

    num
}
